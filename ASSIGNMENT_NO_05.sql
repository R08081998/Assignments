CREATE DATABASE ASSIGNMENT_NO_05;
CREATE TABLE DEPARTMENT_A
(
E_ID INT,
F_NAME VARCHAR(20),
DEPT_ID INT FOREIGN KEY REFERENCES DEPARTMENT_B (DEPT_ID)
);
INSERT INTO DEPARTMENT_A VALUES (101,'AMIT',10),(102,'SUNIL',10),(103,'SUJIT',20),(104,'RAVI',20),(105,'MAYANK',30);
SELECT*FROM DEPARTMENT_A;

CREATE TABLE DEPARTMENT_B
(DEPT_ID INT PRIMARY KEY ,
DEPT_NM VARCHAR(20)
)
INSERT INTO DEPARTMENT_B VALUES (10,'HR'),(20,'IT'),(40,'SALES');
SELECT *FROM DEPARTMENT_B;




-----------QUE NO 01------
----Write a query to get the DepartmentÂ name and employee count for each department------

SELECT DEPT_ID, COUNT(DEPT_ID) AS DEP FROM DEPARTMENT_A WHERE DEPT_ID>1 GROUP BY DEPT_ID;
SELECT * FROM DEPARTMENT_A AS A FULL JOIN DEPARTMENT_B AS B ON A.DEPT_ID=B.DEPT_ID

SELECT DEPT_NM ,COUNT(F_NAME) AS COUNT FROM DEPARTMENT_A AS A 
FULL JOIN DEPARTMENT_B AS B ON A.DEPT_ID=B.DEPT_ID GROUP BY DEPT_NM;---ANS
-----------QUE NO 02------
----If Source employee id is present in Target employee, then output status should be updatedÂ if not present in target table, 
--then INSERTÂ and target employee id is not present in source then mark as DELETE-----
CREATE TABLE SRC_EMP_2020
(E_ID INT,
F_NAME VARCHAR(30),
DEPT_ID INT
)

INSERT INTO SRC_EMP_2020 VALUES (101,'AMIT',10),(102,'SUNIL',10),(103,'SUJIT',20),(104,'RAVI',20),(105,'MAYANK',30)
SELECT * FROM SRC_EMP_2020;

CREATE TABLE TARGET_EMP_2020
(EMP_ID INT,
SAL DECIMAL(10,1)
)
INSERT INTO TARGET_EMP_2020 VALUES (101,500),(102,900),(106,1000)
SELECT * FROM TARGET_EMP_2020;

SELECT ISNULL (E_ID,EMP_ID) EMP_ID ,
CASE 
WHEN E_ID=EMP_ID THEN 'UPDATE'
WHEN EMP_ID IS NULL THEN 'INSERT'
ELSE 'DELETE' END AS STATUS1
FROM SRC_EMP_2020 FULL JOIN TARGET_EMP_2020 ON E_ID=EMP_ID;

SELECT COALESCE(E_ID,EMP_ID) EMP_ID , 
CASE 
WHEN E_ID=EMP_ID THEN 'UPDATE'
WHEN EMP_ID IS NULL THEN 'INSERT'
ELSE 'DELETE' END AS STATUS1
FROM SRC_EMP_2020 FULL JOIN TARGET_EMP_2020 ON E_ID=EMP_ID;---ANS

-----------QUE NO 03------
/*----3.	Write a query to get the emp_id from SRC_EMP_2020 which is not there at TRG_EMP_2020.
As given below*/

SELECT*FROM SRC_EMP_2020;
SELECT*FROM TARGET_EMP_2020;

SELECT E_ID AS EMP_ID FROM SRC_EMP_2020
EXCEPT
SELECT EMP_ID FROM TARGET_EMP_2020;---ANS

-----------QUE NO 04------
/*Write a query to get the department wise second highest salary*/

CREATE TABLE SALARY_FULL
(E_ID INT,
F_NM VARCHAR(10),
DEPT_ID INT,
SALARY DECIMAL(10,0)
)
INSERT  INTO SALARY_FULL VALUES (101,'A',10,500),(102,'B',10,600),(103,'C',20,9000),(104,'D',20,1000),(105,'E',30,1200),(106,'F',10,500),(105,'G',20,1200)
SELECT*FROM SALARY_FULL;

SELECT DISTINCT DEPT_ID,SALARY FROM (
SELECT E.*, DENSE_RANK() OVER ( PARTITION BY DEPT_ID ORDER BY SALARY DESC ) AS RANK_SALARY FROM SALARY_FULL E) E
WHERE RANK_SALARY=2----ANS

-----------QUE NO 05------
/*Write a query to get second highest salary for each department if there is no second highest salary then give first salary */

SELECT DEPT_ID,SALARY FROM (
SELECT DEPT_ID,SALARY, DENSE_RANK() OVER ( PARTITION BY DEPT_ID ORDER BY SALARY DESC) AS FGH,
 COUNT(*)   OVER ( PARTITION BY DEPT_ID ORDER BY DEPT_ID )  AS FJJBGKJ
FROM SALARY_FULL) F WHERE FGH=2 OR FJJBGKJ=1 GROUP BY DEPT_ID,SALARY ;------ANS

-----------QUE NO 06------
/* Write a query to get the row-wise maximum value*/
CREATE TABLE VALUE_INPUT
(Valu_e_1 INT,
Valu_e_2 INT,
Valu_e_3 INT,
Valu_e_4 INT
)
INSERT INTO VALUE_INPUT VALUES (400,250,650,780),(500,690,450,950),(900,550,850,650),(450,890,630,320),(850,870,990,520)
SELECT * FROM VALUE_INPUT;

SELECT Valu_e_1,Valu_e_2 ,Valu_e_3 ,Valu_e_4,  (SELECT MAX(VALUE) 
FROM (VALUES  (Valu_e_1),(Valu_e_2) ,(Valu_e_3) ,(Valu_e_4)) AS X_VALUE(VALUE)) AS MAX_VALUE
FROM VALUE_INPUT;---ANS

SELECT *, GREATEST( Valu_e_1,Valu_e_2,Valu_e_3,Valu_e_4) AS MAX_VALUE FROM VALUE_INPUT-----ANS

SELECT *, LEAST( Valu_e_1,Valu_e_2,Valu_e_3,Valu_e_4) AS MIN_VALUE  FROM VALUE_INPUT-----ANS
	 
-----------QUE NO 07------
/* Write a query to get the expected output as below*/
CREATE TABLE INPUT
(Id INT,
Nm VARCHAR(7),
Salary INT
)
INSERT INTO INPUT VALUES (1,'AAA',500),(2,'BBB',900),(3,'VVVV',700),(4,'CCCC',600),(5,'RRRR',300)
SELECT*FROM INPUT;

SELECT * FROM INPUT 
UNION ALL
SELECT 6,'TOTAL', SUM(SALARY) AS TOTAL_SALARY -----------
FROM INPUT;---------ANS

SELECT ID,NM,SALARY from INPUT 				      --SELECTED ALL ROWS
UNION ALL												  --COMBINE BOTH SELECT SSTATEMENT
SELECT MAX(ID)+1,'TOTAL',SUM(SALARY) FROM INPUT-----ANS              
----SELECT MAX(ID) +1 USED HIGHEST ID & ADD (1) ONE FOR NEXT ID NUMBER GET 6 ID AS ID_NUMBER

-----------QUE NO 08------
/*Write a query to get the user who is not yet travel to given city. Expected output is as below*/

CREATE TABLE INPUT_QUE_NO_08
(Use_r_Name VARCHAR(10)
)
CREATE TABLE INPUT_QUE_NO_008
(

City_Travel VARCHAR(10)
)
INSERT INTO INPUT_QUE_NO_08 VALUES ('Sumit'),('Sumit'),('Aniket'),('Vaibhav')
SELECT * FROM INPUT_QUE_NO_08;


insert into  INPUT_QUE_NO_008 values ('Pune'),('Mumbai'),('Delhi'),('Panji')
SELECT * FROM INPUT_QUE_NO_008;
SELECT * FROM INPUT_QUE_NO_08;

CREATE TABLE INPUT_QUE_NO_00008
(
Use_r_Name VARCHAR(10),
City_Travel VARCHAR(10)
)

INSERT INTO INPUT_QUE_NO_00008 VALUES ('Sumit','Pune'),('Sumit','Mumbai'),('Aniket','Delhi'),('Vaibhav','Panji')

SELECT * FROM INPUT_QUE_NO_08 cross join INPUT_QUE_NO_008 
except 
SELECT * FROM INPUT_QUE_NO_00008;-----ANS

SELECT DISTINCT  PER.Use_r_Name ,City.City_Travel
FROM INPUT_QUE_NO_00008 AS PER , INPUT_QUE_NO_00008 AS CITY
WHERE PER.Use_r_Name != City.Use_r_Name --------ANS

-----------QUE NO 09------
/* What is CET (Common Expression Table) in SQL Server?*/

/*A Common Table Expression, also called as CTE in short form, is a temporary named result set that you can reference
within a SELECT, INSERT, UPDATE, or DELETE statement. The CTE can also be used in a View.
In this article, we will see in detail about how to create and use CTEs from our SQL Server.*/

-----------QUE NO 10------
CREATE TABLE STORE_DTL
(Store_ID INT,
Store_Nm VARCHAR(30),
Store_Add VARCHAR(MAX)
)
INSERT INTO STORE_DTL VALUES (201,'Mordern Store','Mumbai'),(202,'Shivneri Store','Delhi'),(203,'Quality Store','Bangalore'),
(204,'Bharat General Store','Chennai'),(205,'City Store','Kolkata');

CREATE TABLE Prod_Details
(Prod_id INT,
Prod_Name VARCHAR(30),
Price INT,
Store_Id INT
)
INSERT INTO Prod_Details VALUES(10,'Nike',5000,201),(20,'Puma',7000,204),(30,'Addidas',5000,204),(40,'Reeebok',3500,205),
(50,'Woodland',7800,201),(60,'Jordan',8500,205),(70,'Vans',2500,203),(80,'Red Chief',4700,203)

SELECT*FROM STORE_DTL
SELECT*FROM Prod_Details
/*1 . Display store details whose sales exceed 10000 RS. */

---(SELECT*FROM STORE_DTL F LEFT OUTER JOIN Prod_Details G ON F.Store_ID=G.Store_Id ) AS FGHJ 


SELECT STORE_ID, SUM(PRICE) ASFJ FROM Prod_Details GROUP BY Store_Id;

SELECT*FROM STORE_DTL LEFT OUTER JOIN (SELECT STORE_ID, SUM(PRICE) AS ASFJ FROM Prod_Details GROUP BY Store_Id) AS FULLL ON STORE_DTL.Store_ID=FULLL.Store_Id 

SELECT F.STORE_ID FROM STORE_DTL F LEFT OUTER  JOIN Prod_Details G ON F.Store_ID=G.Store_Id GROUP BY F.STORE_ID HAVING SUM(PRICE)>10000;

SELECT*FROM STORE_DTL  JOIN (SELECT STORE_ID, SUM(PRICE) ASFJ FROM Prod_Details GROUP BY Store_Id) AS FUDLL
ON STORE_DTL.STORE_ID=FUDLL.STORE_ID
WHERE ASFJ>10000;-----ANS

SELECT S.STORE_ID,S.STORE_NM,S.STORE_ADD,SUM(P.PRICE) FROM STORE_DTL S	---JOINED TWO TABLE BUT REMOVE PRICE COLUMN FOR TAKING SUM CONDITION 
		INNER JOIN Prod_Details P
		ON S. STORE_ID = P.STORE_ID
		GROUP BY S.STORE_ID,S.STORE_NM,S.STORE_ADD
		HAVING SUM(P.PRICE)> 10000;------ANS

/*	Show store-wise ( Store_Nm ) average sale*/
SELECT*FROM STORE_DTL  JOIN (SELECT STORE_ID, AVG(PRICE) ASFJ FROM Prod_Details GROUP BY Store_Id)
AS FULLL ON STORE_DTL.Store_ID=FULLL.Store_Id;

/*Show store-wise average prices where average sales are between 10000 and 20000*/

SELECT*FROM STORE_DTL  JOIN (SELECT STORE_ID, AVG(PRICE) ASFJ FROM Prod_Details GROUP BY Store_Id)  AS FULLL 
ON STORE_DTL.Store_ID=FULLL.Store_Id
WHERE (ASFJ BETWEEN 10000 AND 20000);-----ANS   -------FOR OUTPUT WE CAN TRY 6000 AND 6400

--OUTPUT= There is no store which Average Sales is between 10000 and 20000.

-----------QUE NO 11------
CREATE TABLE EMP_DTL
(EID INT,
ENM VARCHAR(30),
GENDER VARCHAR(5),
SAL INT,
DID INT
)
INSERT INTO EMP_DTL VALUES (10,'ABHIJEET','M',12000,100),(20,'RAVI','M',12000,100),(50,'ASHISH','M',50000,100),(30,'KAVITA','F',27000,200),(60,'PRIYA','F',76000,200),
(100,'SNEHA','F',60000,200),(110,'PRATIK','M',78000,200),(40,'VIDYA','F',23000,900),(90,'SWATI','F',25000,900),(70,'SUHAS','M',43000,999),
(80,'SUMIT','M',45000,999),(180,'SUMIT','M',45000,800),(180,'Minakshi','M',45000,750)

SELECT*FROM EMP_DTL;
/*1 .Find details of departments that employ more than 1 person and employ both men and women*/
SELECT*FROM EMP_DTL WHERE GENDER='M'
EXCEPT
SELECT*FROM EMP_DTL WHERE GENDER<>'F'

SELECT DID, ENM,GENDER
FROM EMP_DTL 
WHERE DID IN (
    SELECT DID
    FROM EMP_DTL 
    WHERE DID = DID
    GROUP BY DID
    HAVING COUNT(DISTINCT Gender) = 2  AND COUNT(*) > 1 );--------ANS
      

/*COUNT(DISTINCT EID)>1
	AND COUNT(CASE WHEN Gender='M' THEN EID END)>0
	AND COUNT(CASE WHEN Gender='F' THEN EID END)>0 */

SELECT EID,ENM,GENDER,SAL,DID,COUNT(DID) AS DIDCOUNT FROM EMP_DTL WHERE DID>1 GROUP BY EID,ENM,GENDER,SAL,DID;
/*2 .Show gender count department wise*/

SELECT DID,COUNT(*) AS TOTAL,
COUNT(CASE WHEN GENDER='M' THEN 1 END) AS MALE,
COUNT(CASE WHEN GENDER='F'THEN 1 END) AS FEMALE
FROM EMP_DTL GROUP BY DID;---ANS

/*3.	Find the 6th highest paid employee*/
SELECT*FROM(
SELECT F.*,DENSE_RANK() OVER(ORDER BY SAL DESC ) AS RANK_SAL FROM EMP_DTL F)F WHERE RANK_SAL=6;--ANS

SELECT*FROM(
SELECT F.*,ROW_NUMBER() OVER(ORDER BY SAL  ) AS RANK_SAL FROM EMP_DTL F)F WHERE RANK_SAL=6;---ANS

/* 4.Find out the details of the employees, the salary is higher than the average salary of their own department*/

SELECT*FROM EMP_DTL WHERE SAL>(SELECT AVG(SAL) AS AVGSAL FROM EMP_DTL);----ANS

SELECT * FROM(
SELECT E.*,
AVG(SAL) OVER ( PARTITION BY DID ORDER BY DID ) AS AVG_SAL FROM EMP_DTL E) E 
WHERE SAL >AVG_SAL;-----ANS                                              ------ IT IS TAKEN AVG SALARY FROM EACH COMMAN DEPT 

/*5.	What is the inline view creating an example on the below query*/
--SELECT statement in the FROM-clause of another SELECT statement to create a temporary table that could be referenced by the SELECT statement


-----------QUE NO 12------
/*Write a query to get the sum of positive and negative numbers.*/
CREATE TABLE VALUE_12
(POS_Neg_Values INT
)
INSERT INTO VALUE_12 VALUES(-5),(-3),(2),(7),(-10),(8),(12),(-3)
SELECT*FROM VALUE_12;

SELECT SUM (CASE WHEN POS_Neg_Values >=0 THEN 1 ELSE 0 END) AS Sum_Pos_Values,
       SUM (CASE WHEN POS_Neg_Values <0 THEN 1 ELSE 0 END) AS Sum_Neg_Values
	   FROM VALUE_12;

SELECT SUM (CASE WHEN POS_Neg_Values >=0 THEN  POS_Neg_Values ELSE 0 END) AS Sum_Pos_Values,
       SUM (CASE WHEN POS_Neg_Values <0 THEN  POS_Neg_Values ELSE 0 END) AS Sum_Neg_Values
	   FROM VALUE_12;---ANS

-----------QUE NO 13------
/*Write a query to get the output as expected below*/
CREATE TABLE CUST_SRC_1
(CUST_ID INT,
CUST_CITY VARCHAR(30)
)

INSERT INTO CUST_SRC_1 VALUES(101,'PUNE'),(102,'DELHI'),(103,'CHENNAI'),(104,'PUNE'),(107,'PUNE')

CREATE TABLE CUST_SRC_2
(CUST_ID INT,
CUST_CITY VARCHAR(30)
)
INSERT INTO CUST_SRC_2 VALUES(101,'PUNE'),(109,'DELHI'),(105,'CHENNAI'),(104,'PUNE');

SELECT*FROM CUST_SRC_1
SELECT*FROM CUST_SRC_2


SELECT COALESCE (R.CUST_ID,B.CUST_ID),COALESCE(R.CUST_CITY,B.CUST_CITY),---------------------------COALESCE ANS ISNULL ARE GIVEING SAME OP--
CASE 
WHEN R.CUST_ID IS NULL THEN 'DELETE'
WHEN B.CUST_ID IS NULL THEN 'INSERT'
ELSE 'UPDATE' END AS STATUS1
FROM CUST_SRC_1 AS R FULL JOIN CUST_SRC_2 AS B ON R.CUST_ID=B.CUST_ID;-------ANS


/*MERGE INTO CUST_SRC_2 A
USING CUST_SRC_1 B
ON (A.CUST_ID=B.CUST_ID)
WHEN MATCHED THEN 
UPDATE SET A.CUST_CITY=B.CUST_CITY 
WHEN NOT MATCHED by target THEN 
INSERT (CUST_ID,CUST_CITY)
VALUES(CUST_ID,CUST_CITY) 
WHEN NOT MATCHED by source THEN 
delete;*/


-----------QUE NO 14------
/* Write the query to get the specified join and set operator count on the given tables*/

CREATE TABLE TABLE_A
(ID INT
)
INSERT INTO TABLE_A VALUES (1),(1),(1),(2),(2),(2),(3)
CREATE TABLE TABLE_B
(ID INT)
INSERT INTO TABLE_B VALUES (1),(1),(1),(2),(2),(2),(3),(NULL)

SELECT*FROM TABLE_A
SELECT*FROM TABLE_B
/*1.	LEFT OUTER JOIN COUNT*/

SELECT*FROM TABLE_A A LEFT OUTER JOIN TABLE_B B ON A.ID=B.ID;

/*2.	RIGHT OUTER JOIN COUNT*/

SELECT*FROM TABLE_A A RIGHT OUTER JOIN TABLE_B B ON A.ID=B.ID;

/*3.	FULL OUTER JOIN COUNT*/
SELECT*FROM TABLE_A A FULL OUTER JOIN TABLE_B B ON A.ID=B.ID;

/*4.	INNER OUTER JOIN COUNT*/
SELECT*FROM TABLE_A A 	INNER  JOIN  TABLE_B B ON A.ID=B.ID;
/*5.	UNION COUNT*/

SELECT*FROM TABLE_A UNION SELECT*FROM TABLE_B
/*6.	UNION ALL COUNT*/

SELECT*FROM TABLE_A UNION ALL SELECT*FROM TABLE_B

/*6.INTERSECT COUNT*/

SELECT*FROM TABLE_A INTERSECT SELECT*FROM TABLE_B

/*6.EXCEPT COUNT*/
SELECT*FROM TABLE_A EXCEPT SELECT*FROM TABLE_B

-----------QUE NO 15------
/*Mark IS_GREATER_THAN_SYS_DATE column as a Y when HIRE_DATE_IN_MM and
HIRE_DATE_IN_YYYY column values are greater than SYSTEM month and SYSTEM date Year*/

CREATE TABLE SOURCE_TABLE
(HIRE_DATE_IN_MM INT,
HIRE_DATE_IN_YYYY INT
)
INSERT INTO SOURCE_TABLE VALUES(11,2019),(10,2028),(8,2023),(2,2025),(1,2015),(4,2021),(11,2027);
SELECT*FROM SOURCE_TABLE;

SELECT *,
    CASE 
        WHEN HIRE_DATE_IN_YYYY > YEAR(GETDATE()) 
             OR HIRE_DATE_IN_YYYY = YEAR(GETDATE()) 
                 AND HIRE_DATE_IN_MM > MONTH(GETDATE()) 
        THEN 'Y'
        ELSE 'N'
    END AS IS_GREATER_THAN_SYS_DATE
FROM SOURCE_TABLE; ---- ANS



-----------QUE NO 16------
SELECT*FROM SOURCE_TABLE_Q16;

/*1.Write a query to identify whether PROD_NUM is duplicate or not as given below*/

SELECT PROD_NUM ,COUNT(*) AS DUPLICATE_COUNT
FROM SOURCE_TABLE_Q16 GROUP BY PROD_NUM HAVING COUNT(*)>1;

SELECT PROD_NUM ,COUNT(*) AS DUPLICATE_COUNT,
CASE
WHEN  COUNT(*)>1 THEN 'Y' ELSE  'N' END AS IS_DUPLICATE
FROM SOURCE_TABLE_Q16 GROUP BY PROD_NUM;-----ANS

/*2.Write a query to get PROD_NUM wise Sum of Total_Flex_Units If the sum is Integer value or complete number.*/
SELECT PROD_NUM ,ROUND(SUM(TOTAL_FLEX_UNITS),2) AS TOTAL_TOTAL_FLEX_UNITS
FROM SOURCE_TABLE_Q16 GROUP BY PROD_NUM
HAVING SUM(TOTAL_FLEX_UNITS)=FLOOR(SUM(TOTAL_FLEX_UNITS));----ANS

SELECT*FROM
(SELECT PROD_NUM ,ROUND(SUM(TOTAL_FLEX_UNITS),2) AS TOTAL_TOTAL_FLEX_UNITS
FROM SOURCE_TABLE_Q16 GROUP BY PROD_NUM)  AAA 
WHERE TOTAL_TOTAL_FLEX_UNITS=FLOOR(TOTAL_TOTAL_FLEX_UNITS)----ANS

-----------QUE NO 17------
/*•	Write a query to mark IS_REVERSE_QTY column as REVERSE QTY when We have two records for each product number (PROD_NUM)
their Quantity (QTY) is reverse (Values are same but their sign is opposite to each other like + and -).*/

SELECT*FROM SOURCE_QUE_NO_17;

SELECT PROD_NUM,
CASE 
WHEN SUM_QTY = 0 THEN 'REVERSE_QTY'  ELSE 'NOT_REVERSE_QTY'  END  AS IS_REVERSE_QTY	    ----APPLY CASE STATEMENT AFTER SUM (2)								
 FROM 												  
( SELECT PROD_NUM, SUM(QTY) AS SUM_QTY	                                               -- FRIST TOOK PROD_NUM WISE SUM USING GROUP BY (1)
 FROM  SOURCE_QUE_NO_17
 GROUP BY PROD_NUM ) A----ANS
 -------------------------------

 SELECT PROD_NUM,
CASE 
WHEN SUM_QTY = 0 AND COUNT_QTY = 2  THEN 'REVERSE_QTY'  ELSE 'NOT_REVERSE_QTY'  END  AS IS_REVERSE_QTY		 ----APPLY CASE STATEMENT AFTER SUM (2)
								
 FROM 												  
( SELECT PROD_NUM, SUM(QTY) AS SUM_QTY, count(QTY) AS COUNT_QTY 	 -- FRIST TOOK PROD_NUM WISE SUM USING GROUP BY (1)
FROM  SOURCE_QUE_NO_17
GROUP BY PROD_NUM ) A;----ANS

-----------QUE NO 18------
SELECT*FROM SOURCE_QUE_NO_18;
/*1.	Write a query to populate the SUGGESTED_ERROR_WARNINGÂ column*/

ALTER TABLE SOURCE_QUE_NO_18
ADD  SUGGESTED_ERROR_WARNINGÂ  VARCHAR(50);

/*2.Compare SYS_CONVERTED_RAW_UNITS columns values with either FLEX_CONVERTED_UNITS or SY_CONVERTED_PKG_QTY 
column based on the value of METRIC_FOR_QTY_VALIDATION column

	If METRIC_FOR_QTY_VALIDATION columns value is PACKAGE then compare SYS_CONVERTED_RAW_UNITS columns
with SY_CONVERTED_PKG_QTY column and if the values are not matching then mark QTY_CONVERSION_IS_NOT_MATCHED error

If METRIC_FOR_QTY_VALIDATION columns value is UNIT then compare SYS_CONVERTED_RAW_UNITS columns with FLEX_CONVERTED_UNITS
column and if the values are not matching then mark QTY_CONVERSION_IS_NOT_MATCHED error.*/


CREATE TABLE SOURCE_QUE_NO_18
(TXN_ID INT, PAYER_NAME VARCHAR(50),SYS_CONVERTED_RAW_UNITS INT, FLEX_CONVERTED_UNITS INT,SY_CONVERTED_PKG_QTY INT,METRIC_FOR_QTY_VALIDATION VARCHAR(50)
)

BEGIN TRAN

UPDATE SOURCE_QUE_NO_18
SET SUGGESTED_ERROR_WARNINGÂ =                
CASE
WHEN METRIC_FOR_QTY_VALIDATION= 'PACKAGE' AND SYS_CONVERTED_RAW_UNITS != SY_CONVERTED_PKG_QTY THEN 'QTY_CONVERSION_IS_NOT_MATCHED'
WHEN METRIC_FOR_QTY_VALIDATION='UNIT' AND SYS_CONVERTED_RAW_UNITS<> FLEX_CONVERTED_UNITS THEN 'QTY_CONVERSION_IS_NOT_MATCHED'  
ELSE ''END;-----ANS

ROLLBACK

SELECT*FROM SOURCE_QUE_NO_18;
SELECT*,
CASE
WHEN METRIC_FOR_QTY_VALIDATION= 'PACKAGE' AND SYS_CONVERTED_RAW_UNITS != SY_CONVERTED_PKG_QTY THEN 'QTY_CONVERSION_IS_NOT_MATCHED'
WHEN METRIC_FOR_QTY_VALIDATION='UNIT' AND SYS_CONVERTED_RAW_UNITS<> FLEX_CONVERTED_UNITS THEN 'QTY_CONVERSION_IS_NOT_MATCHED'  
ELSE ''END AS SUGGESTED_ERROR_WARNINGÂ FROM SOURCE_QUE_NO_18;----ANS
 
-----------QUE NO 19-------------------------------------------------------------------------------------------------------
/*1.Write a query to get the brand wise sum of total flex units for valid ndc only*/

CREATE TABLE SOURCE_QUE_NO_19
(TXN_ID INT,Brand VARCHAR(50),NDC VARCHAR(50),IS_VALID_NDC VARCHAR(50),	Total_Flex_Units DECIMAL(5,1) )

SELECT*FROM SOURCE_QUE_NO_19;

SELECT BRAND, SUM(Total_Flex_Units) AS TOTAL_Total_Flex_Units
FROM SOURCE_QUE_NO_19 WHERE IS_VALID_NDC='Y'
GROUP BY BRAND;------ANS

/*2.Write a query to get the brand wise and is_valid_ndc wise record count*/

SELECT BRAND, IS_VALID_NDC, COUNT(*) AS RECORD_COUNT
FROM SOURCE_QUE_NO_19
GROUP BY BRAND, IS_VALID_NDC;------ANS
/*3.Write a query to get the brand wise sum of total flex units with subtotal*/

SELECT ISNULL (BRAND,'TOTAL')AS BRAND, SUM(total_flex_units) AS total_flex_units_sum
FROM SOURCE_QUE_NO_19  WHERE IS_VALID_NDC='Y'
GROUP BY BRAND
WITH ROLLUP;

SELECT COALESCE (BRAND,'TOTAL')AS BRAND, SUM(total_flex_units) AS total_flex_units_sum
FROM SOURCE_QUE_NO_19  WHERE IS_VALID_NDC='Y'
GROUP BY BRAND
WITH ROLLUP;-------ANS

-----------QUE NO 20------
CREATE TABLE SOURCE_QUE_NO_20 
(TXN_ID INT,PAYER_NAME VARCHAR(50),	SYS_CONVERTED_RAW_UNITS INT,Min_Qty FLOAT,Max_Qty FLOAT)
SELECT*FROM SOURCE_QUE_NO_20;
/*1.	Write a query to populate the Validation column*/
ALTER TABLE SOURCE_QUE_NO_20
ADD  Valid_ation VARCHAR(50);
/*2.If SYS_CONVERTED_RAW_UNITS is greater than Min_Qty and less than Max_Qty then its valid record else its invalid record*/

BEGIN TRAN

UPDATE SOURCE_QUE_NO_20
SET Valid_ation=
CASE 
WHEN SYS_CONVERTED_RAW_UNITS>MIN_QTY AND SYS_CONVERTED_RAW_UNITS<MAX_QTY THEN 'VALIED' ELSE 'NOT VALIED'
END;

ROLLBACK
SELECT*FROM SOURCE_QUE_NO_20;

SELECT*,
CASE 
WHEN SYS_CONVERTED_RAW_UNITS>MIN_QTY AND SYS_CONVERTED_RAW_UNITS<MAX_QTY THEN 'VALIED' ELSE 'NOT VALIED'
END AS VALID_ADITION FROM SOURCE_QUE_NO_20;----ANS

-----------QUE NO 21------
CREATE TABLE SOURCE_QUE_NO_21
(SALES_AMOUNT_CURRENCY VARCHAR(MAX)
)
INSERT INTO SOURCE_QUE_NO_21 VALUES ('112.84EUR'),('90.28USD'),('1.48EUR'),('4.52INR'),('90.28NZD'),('112.84PKR'),('45.14USD'),('90.28USD'),
('34.87USD'),('139.48USD'),('6.97USD'),('139.48USD'),('6.97USD'),('139.48USD'),('139.48USD'),('69.74USD'),('139.48INR'),('6.97INR'),('1.48PKR'),
('139.48PKR');

SELECT*FROM SOURCE_QUE_NO_21;

SELECT PARSENAME (REPLACE(SALES_AMOUNT_CURRENCY,'','.'),2) AS SALES_AMOUNT,
       PARSENAME (REPLACE(SALES_AMOUNT_CURRENCY,'','.'),1) AS SALES_CURRENCY
FROM SOURCE_QUE_NO_21;

SELECT
TRANSLATE(SALES_AMOUNT_CURRENCY, TRANSLATE(SALES_AMOUNT_CURRENCY,'0123456789','          '),SPACE (LEN(TRANSLATE(SALES_AMOUNT_CURRENCY,'0123456789','          ')))) AS SALES_AMOUNT,
TRIM (TRANSLATE(SALES_AMOUNT_CURRENCY,'0123456789','          ')) AS CURRENCY FROM SOURCE_QUE_NO_21;

SELECT
    SUBSTRING(SALES_AMOUNT_CURRENCY, 1, CHARINDEX('.', SALES_AMOUNT_CURRENCY) + 2) AS SALES_AMOUNT,
    SUBSTRING(SALES_AMOUNT_CURRENCY, CHARINDEX('.', SALES_AMOUNT_CURRENCY) + 3, LEN(SALES_AMOUNT_CURRENCY)) AS CURRENCY
FROM SOURCE_QUE_NO_21;----ANS
    
SELECT 
    SUBSTRING(SALES_AMOUNT_CURRENCY, 1, PATINDEX('%[^0-9.]%', SALES_AMOUNT_CURRENCY) - 1) AS SALES_AMOUNT,
    SUBSTRING(SALES_AMOUNT_CURRENCY, PATINDEX('%[^0-9.]%', SALES_AMOUNT_CURRENCY) + 1, LEN(SALES_AMOUNT_CURRENCY)) AS CURRENCY
FROM SOURCE_QUE_NO_21;


 select * from SOURCE_QUE_NO_21
-----------QUE NO 22------
CREATE TABLE INPUT_QUE_NO_22
(J_CODE VARCHAR(50))

INSERT INTO INPUT_QUE_NO_22 VALUES('BILATERAL'),('BILATERAL ICD-1089'),('BILATERAL'),('ICD-1090'),('ICD-1056'),('ICD-1089'),('VPI-202901 BILATERAL'),
('ICD-1090'),('ICD-1090');

SELECT*FROM INPUT_QUE_NO_22;

SELECT  J_CODE AS J_CODE,  
CASE
 WHEN CHARINDEX('-', J_CODE) > 0 THEN LEFT(J_CODE, CHARINDEX('-', J_CODE) - 1)  ELSE J_CODE     END AS EXPECTED_OUTPUT_1,
 CASE
 WHEN CHARINDEX('-', J_CODE) > 0 THEN SUBSTRING(J_CODE, CHARINDEX('-', J_CODE) + 1, LEN(J_CODE)) ELSE J_CODE
  END AS EXPECTED_OUTPUT_2
FROM INPUT_QUE_NO_22; ---ANS

/*NEED EXPECTED TWO COLUMN WITH CASE CONDITION NEED TO WRIGHT TWO CASE STATEMENT
IF NEED EXPECTED ONE COLUMN WITH MULTIPLE CONDITION NEED TO RIGHT MULTIPAL WHEN */

-----------QUE NO 23------
CREATE TABLE SOURCE_QUE_NO_23
(SERVICE_DT_QTR VARCHAR(MAX) )

INSERT INTO SOURCE_QUE_NO_23 VALUES('2020Q3'),('2020Q3'),('2020Q3'),('2020Q3'),('2020Q3'),('2020Q4'),('2018Q4'),('2019Q4'),
('2021Q3'),('2020Q3'),('2020Q3'),('2020Q3'),('2020Q1'),('2020Q3'),('2020Q1');

SELECT*FROM SOURCE_QUE_NO_23;

SELECT
 SERVICE_DT_QTR,
DATEFROMPARTS
  (CAST(SUBSTRING(SERVICE_DT_QTR, 1, 4) AS INT), 
 (CAST(SUBSTRING(SERVICE_DT_QTR, 6, 1) AS INT) - 1) * 3+1, 1 )        
     AS SERVICE_QTR_START_DT
FROM SOURCE_QUE_NO_23;----ANS

SELECT 
    SERVICE_DT_QTR,
    CASE 
        WHEN RIGHT(SERVICE_DT_QTR, 2) = 'Q1' THEN CAST(SUBSTRING(SERVICE_DT_QTR, 1, 4) + '-01-01' AS DATE)
        WHEN RIGHT(SERVICE_DT_QTR, 2) = 'Q2' THEN CAST(SUBSTRING(SERVICE_DT_QTR, 1, 4) + '-04-01' AS DATE)
        WHEN RIGHT(SERVICE_DT_QTR, 2) = 'Q3' THEN CAST(SUBSTRING(SERVICE_DT_QTR, 1, 4) + '-07-01' AS DATE)
        WHEN RIGHT(SERVICE_DT_QTR, 2) = 'Q4' THEN CAST(SUBSTRING(SERVICE_DT_QTR, 1, 4) + '-10-01' AS DATE)
        ELSE NULL -- If there's an unexpected value in SERVICE_DT_QTR
    END AS ConvertedDate
FROM SOURCE_QUE_NO_23;

-----------QUE NO 24------
CREATE TABLE SOURCE_QUE_NO_24
(SERVICE_DT DATE )
SELECT*FROM SOURCE_QUE_NO_24;

SELECT SERVICE_DT,
  CONCAT(
   YEAR(CONVERT(DATE, SERVICE_DT, 105)), 'Q',  
 DATEPART(QUARTER, CONVERT(DATE, SERVICE_DT, 105)) )
   AS SERVICE_DT_QTR
	FROM  SOURCE_QUE_NO_24;------ANS

SELECT SERVICE_DT,
    CASE 
        WHEN MONTH(TRY_CONVERT(DATE, SERVICE_DT, 105)) BETWEEN 1 AND 3 THEN CONCAT(YEAR(TRY_CONVERT(DATE, SERVICE_DT, 105)), 'Q1')
        WHEN MONTH(TRY_CONVERT(DATE, SERVICE_DT, 105)) BETWEEN 4 AND 6 THEN CONCAT(YEAR(TRY_CONVERT(DATE, SERVICE_DT, 105)), 'Q2')
        WHEN MONTH(TRY_CONVERT(DATE, SERVICE_DT, 105)) BETWEEN 7 AND 9 THEN CONCAT(YEAR(TRY_CONVERT(DATE, SERVICE_DT, 105)), 'Q3')
        WHEN MONTH(TRY_CONVERT(DATE, SERVICE_DT, 105)) BETWEEN 10 AND 12 THEN CONCAT(YEAR(TRY_CONVERT(DATE, SERVICE_DT, 105)), 'Q4')
        ELSE NULL -- For invalid date formats
    END AS SERVICE_DT_QTR
FROM SOURCE_QUE_NO_24;------ans

SELECT 
    SERVICE_DT,
    CASE 
        WHEN TRY_CONVERT(DATE, SERVICE_DT, 105) IS NOT NULL 
        THEN CONCAT(YEAR(TRY_CONVERT(DATE, SERVICE_DT, 105)), 'Q', DATEPART(QUARTER, TRY_CONVERT(DATE, SERVICE_DT, 105)))
        ELSE 'Invalid Date'
    END AS SERVICE_DT_QTR
FROM SOURCE_QUE_NO_24;

select * from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME = 'SOURCE_QUE_NO_24'


-----------QUE NO 25------
/*Update the IS_REVIEW_REQUIRED flag with N if it is NULL*/
CREATE TABLE SOURCE_QUE_NO_25
(TXN_ID INT,Brand VARCHAR(50),NDC VARCHAR(50),IS_REVIEW_REQUIRED VARCHAR(50))

SELECT*FROM SOURCE_QUE_NO_25;

SELECT TXN_ID,Brand,NDC,
CASE 
WHEN IS_REVIEW_REQUIRED IS NULL THEN 'N'ELSE IS_REVIEW_REQUIRED END
AS IS_REVIEW_REQUIRED253 FROM SOURCE_QUE_NO_25;

-----------QUE NO 26------
/*•	If PAYER_NAME is ESI, CSV or HIGHMARK, use the REPORT_DESC value, and for other PAYER_NAMEs, 
use the REPORT_NAME value of the MB_REPORT_NAME_CONFIG table*/

SELECT*FROM SOURCE_TXN_DATA;
SELECT*FROM LOOKUP_TABLE_MB_REPORT_NAME_CONFIG;

WITH CTE AS (
    SELECT T.REPORT_ID, T.REPORT_DESC, T.PAYER_NAME, M.REPORT_NAME 
    FROM SOURCE_TXN_DATA AS T
     LEFT JOIN LOOKUP_TABLE_MB_REPORT_NAME_CONFIG AS M ON T.REPORT_ID = M.REPORT_ID 
    WHERE T.PAYER_NAME NOT IN ('ESI', 'CVS', 'HIGHMARK'))
SELECT *FROM CTE;----ANS

SELECT A.REPORT_ID,A.Report_ID,A.PAYER_NAME,
CASE WHEN PAYER_NAME  IN ('ESI','CSV','HIGHMARK') THEN REPORT_DESC ELSE B.REPORT_NAME END
FROM SOURCE_TXN_DATA A LEFT OUTER JOIN LOOKUP_TABLE_MB_REPORT_NAME_CONFIG B 
ON A.Report_ID = B.Report_ID 
ORDER BY A.REPORT_ID;

SELECT  Report_ID,PAYER_NAME,
			CASE 
				WHEN PAYER_NAME  IN ( 'ESI', 'CVS' , 'HIGHMARK') THEN REPORT_DESC
				ELSE 'AVASTIN 1 OF 4 MFR (LEVEL 1 AND LEVEL 2)'
				END	AS REPORT_DETAILS
			FROM  SOURCE_TXN_DATA 	 ;

-----------QUE NO 27------
/*•	If the value of IS_ERROR is Y and ERROR_TYPE is not 340B then append the 340B ERROR_TYPE.
•	If the value of IS_ERROR is N then keep the value of ERROR_TYPE as it is.
•	If the value of ERROR_TYPE is 340B then keep it as it is
*/
CREATE TABLE INPUT_QUE_NO_27
(ERROR_TYPE VARCHAR(50),IS_ERROR VARCHAR(50))

SELECT*FROM INPUT_QUE_NO_27;

SELECT *,
CASE 
WHEN IS_ERROR='Y' AND ERROR_TYPE<>'340B' THEN ERROR_TYPE + '340B'
WHEN IS_ERROR='N' THEN ERROR_TYPE
WHEN ERROR_TYPE='340B' THEN ERROR_TYPE
 END AS OUTPUT_ERROR_TYPE
FROM INPUT_QUE_NO_27-------ANS

-----------QUE NO 28------
/*•	Mark the IS_DUPLICATE flag as Y if the product number is duplicate*/
CREATE TABLE SOURCE_QUE_NO_28
(ID INT,PROD_NUM INT,SERVICE_DT DATE)

SELECT*FROM SOURCE_QUE_NO_28;


SELECT ID,PROD_NUM,SERVICE_DT,
CASE
WHEN PROD_COUNT>1 THEN 'Y' ELSE 'N'END AS IS_DUPLICATE
FROM 
(SELECT ID,PROD_NUM,SERVICE_DT,COUNT(PROD_NUM) OVER(PARTITION BY PROD_NUM ) AS PROD_COUNT
FROM SOURCE_QUE_NO_28 ) A ----ANS

-----------QUE NO 29------
/*•	Compare the NDC of source table with NDC or J_CODE of NDC_CONFIG table.
•	If the source table matches the NDC or J_CODE of the NDC config table, mark it as 'Y', otherwise mark it as 'N'
*/
SELECT*FROM SOURCE_TABLE_QUE_NO_29_1 ;
SELECT*FROM NDC_CONFIG_QUE_NO_29_2;

ALTER TABLE NDC_CONFIG_QUE_NO_29_2
ALTER COLUMN NDC VARCHAR(50);


SELECT S.TXN_ID,S.BRAND,S.NDC,
CASE
 WHEN S.NDC IN (SELECT NDC FROM NDC_CONFIG_QUE_NO_29_2)  OR S.NDC IN (SELECT JCODE FROM NDC_CONFIG_QUE_NO_29_2) THEN 'Y'   ELSE 'N'  END 			  
FROM SOURCE_TABLE_QUE_NO_29_1 S  LEFT OUTER JOIN NDC_CONFIG_QUE_NO_29_2 N ON S.TXN_ID=N.CONFIG_ID;----ANS

-----------QUE NO 30------
/*1.Compare the RAW_UNITS with BillUnits_AQ and TOTAL_PKG_QTY with the Vials_AQ, 
using NDC of Source table with PRODUCT_ID with the ABERRANT_QTY_CONFIG.
2.If RAW_UNITS is greater than BillUnits_AQ or TOTAL_PKG_QTY is greater than Vials_AQ then mark the WARNING_ERROR as ABERRANT QTY
*/
CREATE TABLE SOURCE_QUE_NO_30_1
(TXN_ID INT,NDC VARCHAR(50),DOS_QTR VARCHAR(50),RAW_UNITS INT,TOTAL_PKG_QTY INT)

CREATE TABLE ABARRANT_QT_CONFIG_QUE_NO_30_2
(Product_ID VARCHAR(50),BillUnits_AQ INT,Vials_AQ INT)

SELECT*FROM SOURCE_QUE_NO_30_1;
SELECT*FROM ABARRANT_QT_CONFIG_QUE_NO_30_2;

SELECT TXN_ID,NDC,DOS_QTR,RAW_UNITS,TOTAL_PKG_QTY,
CASE
WHEN RAW_UNITS>BillUnits_AQ OR TOTAL_PKG_QTY>Vials_AQ THEN 'ABERRANT QTY' ELSE ' ' END AS WARNING_ERROR 
FROM SOURCE_QUE_NO_30_1 R
 JOIN 
ABARRANT_QT_CONFIG_QUE_NO_30_2 H ON R.NDC=H.Product_ID;------ANS
SELECT*FROM SOURCE_QUE_NO_30_1;
SELECT*FROM ABARRANT_QT_CONFIG_QUE_NO_30_2;

SELECT TXN_ID,NDC,DOS_QTR,RAW_UNITS,TOTAL_PKG_QTY,
CASE
WHEN RAW_UNITS>BillUnits_AQ OR TOTAL_PKG_QTY>Vials_AQ THEN 'ABERRANT QTY'  END AS WARNING_ERROR 
FROM SOURCE_QUE_NO_30_1 R
 JOIN 
ABARRANT_QT_CONFIG_QUE_NO_30_2 H ON R.NDC=H.Product_ID;-----ANS


-----------QUE NO 31------
/*•	Compare the SYS_CONVERTED_RAW_UNITS and FLEX_CONVERTED_UNITS if absolute values of both are same
then assign value of SYS_CONVERTED_PKG_QTY and
assign the positive and negative sign  (WHEN BOTH ABS COMPARESSION FAILED ELSE 0) of FLEX_CONVERTED_RAW_UNITS to SYS_CONVERTED_PKG_QTY*/

CREATE TABLE INPUT_QUE_NO_31
(TXN_ID INT,PAYER_NAME VARCHAR(50),SYS_CONVERTED_RAW_UNITS INT,FLEX_CONVERTED_UNITS INT,SY_CONVERTED_PKG_QTY INT)

SELECT*FROM INPUT_QUE_NO_31

SELECT *,
CASE 
WHEN ABS(SYS_CONVERTED_RAW_UNITS)=ABS(FLEX_CONVERTED_UNITS)
THEN (CASE WHEN SYS_CONVERTED_RAW_UNITS<0 THEN - SY_CONVERTED_PKG_QTY ELSE SY_CONVERTED_PKG_QTY END)
ELSE 0
END SY_CONVERTED_PKG_QTY 
FROM INPUT_QUE_NO_31;-----ANS

-----------QUE NO 32------
/*	Write a query to split the records as per ASP_RATIO_UNITS as given below.*/
SELECT *FROM MBRA_SOURCE;
SELECT*FROM MBRA_ASP_RATIO_CONFIG;

SELECT GENE_MBRA_TXN_ID,BRAND_NAME,(SYS_CONVERTED_UNITS * ASP_RATIO_UNITS) AS SYS_CONVERTED_UNITS,
DATE_OF_SERVICE	NDC_PRODT_NBR,J_CODE 
FROM MBRA_SOURCE A LEFT OUTER JOIN MBRA_ASP_RATIO_CONFIG B ON A.BRAND_NAME=B.BRAND_NM ;   ----ANS

SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'MBRA_ASP_RATIO_CONFIG'
-----------QUE NO 33------
/*Write a query to get the percentage contribution of each family member.*/

CREATE TABLE Family_Member_Contr
(Family_ID INT,	Family VARCHAR(50),	Family_Member_Name VARCHAR(50),	Contr INT)

SELECT *FROM  Family_Member_Contr;


WITH CTE AS (
SELECT FAMILY,FAMILY_MEMBER_NAME,CONTR,
 SUM(CONTR) OVER (PARTITION BY FAMILY_ID ORDER BY FAMILY_ID ) AS SUM_CONTR        ------WE CALCLULATE SUM AS FAMILY _ID WISE (STEP 1) THIS CTE TABLE
FROM FAMILY_MEMBER_CONTR )                                                      
SELECT FAMILY,FAMILY_MEMBER_NAME,                             
     (CONTR * 100.0 / SUM_CONTR) AS CONTR_IN_PERCENTAGE                           ------THEN WE CLCLULATE % WITH THE HELP OF SUM OF CONTR VCOLUMN WHICH IN CTE TABLE
FROM CTE;------ANS

-----------QUE NO 34------
/*Write a query to get the expectedÂ result.
Note: Use the LISTAGG FUNCTION ------NOTE --- LISTAGG FUNCTION NOT WORKING IN SERVER BUT NEED TO USE STRING_AGG
*/
CREATE TABLE INPUT_QUE_NO_34
(dept INT,nm VARCHAR(20))

INSERT INTO INPUT_QUE_NO_34 VALUES (1,'A'),(1,'B'),(1,'C'),(2,'A'),(2,'B')

SELECT*FROM INPUT_QUE_NO_34;

SELECT dept
     , STRING_AGG(nm, ',') WITHIN GROUP (ORDER BY nm) AS nm
  FROM INPUT_QUE_NO_34
 GROUP BY dept
 ORDER BY dept;------ANS
 -----------QUE NO 35------
/*35.Write a query to get the expected output*/
CREATE TABLE Input_QUE_NO_35
(First_Name VARCHAR(50),Last_Name VARCHAR(50)
)

INSERT INTO Input_QUE_NO_35 VALUES ('Vijay',''),('','Jaiswal'),('Kuldeep',''),('','Solanki'),('Lalsingh',''),('','Bharti'),('Poornaya',''),
('','Cherukmala'),('Rajeev',''),('','TK');

SELECT *FROM Input_QUE_NO_35;


WITH CTE AS (
  SELECT
  ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS rn,
 First_Name, Last_Name   FROM Input_QUE_NO_35
 WHERE First_Name <> '' OR Last_Name <> '')
SELECT
 c1.First_Name AS First_Name,
 c2.Last_Name AS Last_Name
FROM CTE c1
 JOIN CTE c2 ON c1.rn = c2.rn -1
 WHERE  c1.First_Name<> '' 
ORDER BY c1.rn;-------ANS

SELECT * FROM(
SELECT FIRST_NAME,LEAD(LAST_NAME) OVER(ORDER BY rn)LAST_NAME FROM 
(SELECT *,null AS rn FROM Input_QUE_NO_35 ) V						             ---- create temp table for lead operation 
)TEMP
WHERE FIRST_NAME <>'' AND LAST_NAME <>'';------ANS

SELECT *, NULL AS RUSHI FROM Input_QUE_NO_35;---------INTERVIEW QUE

/*WITH CTE AS (
  SELECT
  ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS rn,
 First_Name, Last_Name   FROM Input_QUE_NO_35
-- WHERE First_Name <> '' OR Last_Name <> ''
 )
SELECT
 c1.First_Name AS First_Name,
 c2.Last_Name AS Last_Name
FROM CTE c1
 JOIN CTE c2 ON c1.rn = c2.rn -1
 WHERE  c1.First_Name != ''
--ORDER BY c1.rn;*/

 -----------QUE NO 36------
 /**/

 CREATE TABLE Player	

 (Player_id INT,Player_Name VARCHAR(30)
 )
 INSERT INTO Player VALUES (1,'Nadal'),(2,'Federer'),(3,'Novak');

 CREATE TABLE Championship				
(Yea_r INT,	Wimbledon INT,	Fr_Open INT,US_Open INT,Au_Open INT )
INSERT INTO Championship VALUES (2018,1,1,1,1),(2019,1,1,3,2),(2020,2,1,2,2);

SELECT * FROM Player;
SELECT * FROM Championship;

SELECT distinct(Player_Name)
    Player_id,
    Player_Name,
    Wimbledon + Fr_Open + US_Open + Au_Open AS Grand_Slam_Count
FROM Player , Championship;

SELECT Player_id, Player_Name,
(SUM(IIF(Wimbledon=Player_id,1,0))+SUM(IIF(Fr_Open=Player_id,1,0))+SUM(IIF(US_Open=Player_id,1,0))+SUM(IIF(Au_Open=Player_id,1,0)))
AS GRAND_SLAM_COUNT
FROM PLAYER INNER JOIN CHAMPIONSHIP 
ON Wimbledon =Player_id  OR Fr_Open = Player_id OR US_Open = Player_id OR Au_Open = Player_id
GROUP BY Player_id,Player_Name
ORDER BY Player_id;---------ANS


/*The SUM function is used to add up the results of the IIF functions. 
The IIF function checks
if the player's ID matches the ID of the championship (Wimbledon, French Open, US Open, or Australian Open). 
If there's a match, it returns 1; otherwise, it returns 0.*/

 -----------QUE NO 37------
 CREATE TABLE SOURCE_QUE_NO_37
 (DT DATE)

 SELECT*FROM SOURCE_QUE_NO_37;


 SELECT DT,
CASE WHEN DATEDIFF(DAY,LAG(DT) OVER(ORDER BY DT),DT) >1 THEN 'Y'
ELSE 'N'
END AS Missiing_SEQ_FLG
FROM SOURCE_QUE_NO_37------ANS
